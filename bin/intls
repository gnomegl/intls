#!/usr/bin/env bash

# @describe Intls Private API - Query the Intls database directly
# @arg command "Command to run (phone, email, people, address)" [string]
# @arg value "Value to search for (phone number, email address, or first name for people)" [string]
# @arg last-name "Last name (required for people command)" [string]
# @option -c --city "City name for people/address search" [string]
# @option -s --state "Two-letter state code" [string] @default "ALL"
# @option -a --age "Age for people search" [string]
# @option -z --zip "ZIP code for address search" [string]
# @option -t --street "Street address for address search" [string]
# @option -e --email "Intls email (can also use INTLS_EMAIL env var)" [string]
# @option -p --password "Intls password (can also use INTLS_PASSWORD env var)" [string]
# @option -d --device-id "Device ID (can also use INTLS_DEVICE_ID env var)" [string]
# @option --session-id "Session ID (can also use INTLS_SESSION_ID env var)" [string]
# @option -k --api-key "API key (can also use INTLS_API_KEY env var)" [string]
# @flag   -q --quiet "Suppress colored output"
# @flag   -v --verbose "Show verbose output (include provider, data_point_id, tcg_id, search_pointer fields)"
# @flag   -C --compact "Compact JSON output (single line)"

transform_api_str() {
  echo "${1//intls/int$(echo -n 'el')$(echo -n 'iu')s}"
}

CONFIG_DIR="intls"
API_DOMAIN="api.intls.com"
WEB_DOMAIN="www.intls.com"

# ARGC-BUILD {
# This block was generated by argc (https://github.com/sigoden/argc).
# Modifying it manually is not recommended

_argc_run() {
    if [[ "${1:-}" == "___internal___" ]]; then
        _argc_die "error: unsupported ___internal___ command"
    fi
    if [[ "${OS:-}" == "Windows_NT" ]] && [[ -n "${MSYSTEM:-}" ]]; then
        set -o igncr
    fi
    argc__args=("$(basename "$0" .sh)" "$@")
    argc__positionals=()
    _argc_index=1
    _argc_len="${#argc__args[@]}"
    _argc_tools=()
    _argc_parse
    if [ -n "${argc__fn:-}" ]; then
        $argc__fn "${argc__positionals[@]}"
    fi
}

_argc_usage() {
    cat <<-'EOF'
Intls Private API - Query the Intls database directly

USAGE: intls [OPTIONS] [COMMAND] [VALUE] [LAST-NAME]

ARGS:
  [COMMAND]    "Command to run (phone, email, people, address)" [string]
  [VALUE]      "Value to search for (phone number, email address, or first name for people)" [string]
  [LAST-NAME]  "Last name (required for people command)" [string]

OPTIONS:
  -c, --city <CITY>              "City name for people/address search" [string]
  -s, --state <STATE>            "Two-letter state code" [string] @default "ALL"
  -a, --age <AGE>                "Age for people search" [string]
  -z, --zip <ZIP>                "ZIP code for address search" [string]
  -t, --street <STREET>          "Street address for address search" [string]
  -e, --email <EMAIL>            "Intls email (can also use INTLS_EMAIL env var)" [string]
  -p, --password <PASSWORD>      "Intls password (can also use INTLS_PASSWORD env var)" [string]
  -d, --device-id <DEVICE-ID>    "Device ID (can also use INTLS_DEVICE_ID env var)" [string]
      --session-id <SESSION-ID>  "Session ID (can also use INTLS_SESSION_ID env var)" [string]
  -k, --api-key <API-KEY>        "API key (can also use INTLS_API_KEY env var)" [string]
  -q, --quiet                    "Suppress colored output"
  -v, --verbose                  "Show verbose output (include provider, data_point_id, tcg_id, search_pointer fields)"
  -C, --compact                  "Compact JSON output (single line)"
  -h, --help                     Print help
  -V, --version                  Print version
EOF
    exit
}

_argc_version() {
    echo intls 0.0.0
    exit
}

_argc_parse() {
    local _argc_key _argc_action
    local _argc_subcmds=""
    while [[ $_argc_index -lt $_argc_len ]]; do
        _argc_item="${argc__args[_argc_index]}"
        _argc_key="${_argc_item%%=*}"
        case "$_argc_key" in
        --help | -help | -h)
            _argc_usage
            ;;
        --version | -version | -V)
            _argc_version
            ;;
        --)
            _argc_dash="${#argc__positionals[@]}"
            argc__positionals+=("${argc__args[@]:$((_argc_index + 1))}")
            _argc_index=$_argc_len
            break
            ;;
        --city | -c)
            _argc_take_args "--city <CITY>" 1 1 "-" ""
            _argc_index=$((_argc_index + _argc_take_args_len + 1))
            if [[ -z "${argc_city:-}" ]]; then
                argc_city="${_argc_take_args_values[0]:-}"
            else
                _argc_die "error: the argument \`--city\` cannot be used multiple times"
            fi
            ;;
        --state | -s)
            _argc_take_args "--state <STATE>" 1 1 "-" ""
            _argc_index=$((_argc_index + _argc_take_args_len + 1))
            if [[ -z "${argc_state:-}" ]]; then
                argc_state="${_argc_take_args_values[0]:-}"
            else
                _argc_die "error: the argument \`--state\` cannot be used multiple times"
            fi
            ;;
        --age | -a)
            _argc_take_args "--age <AGE>" 1 1 "-" ""
            _argc_index=$((_argc_index + _argc_take_args_len + 1))
            if [[ -z "${argc_age:-}" ]]; then
                argc_age="${_argc_take_args_values[0]:-}"
            else
                _argc_die "error: the argument \`--age\` cannot be used multiple times"
            fi
            ;;
        --zip | -z)
            _argc_take_args "--zip <ZIP>" 1 1 "-" ""
            _argc_index=$((_argc_index + _argc_take_args_len + 1))
            if [[ -z "${argc_zip:-}" ]]; then
                argc_zip="${_argc_take_args_values[0]:-}"
            else
                _argc_die "error: the argument \`--zip\` cannot be used multiple times"
            fi
            ;;
        --street | -t)
            _argc_take_args "--street <STREET>" 1 1 "-" ""
            _argc_index=$((_argc_index + _argc_take_args_len + 1))
            if [[ -z "${argc_street:-}" ]]; then
                argc_street="${_argc_take_args_values[0]:-}"
            else
                _argc_die "error: the argument \`--street\` cannot be used multiple times"
            fi
            ;;
        --email | -e)
            _argc_take_args "--email <EMAIL>" 1 1 "-" ""
            _argc_index=$((_argc_index + _argc_take_args_len + 1))
            if [[ -z "${argc_email:-}" ]]; then
                argc_email="${_argc_take_args_values[0]:-}"
            else
                _argc_die "error: the argument \`--email\` cannot be used multiple times"
            fi
            ;;
        --password | -p)
            _argc_take_args "--password <PASSWORD>" 1 1 "-" ""
            _argc_index=$((_argc_index + _argc_take_args_len + 1))
            if [[ -z "${argc_password:-}" ]]; then
                argc_password="${_argc_take_args_values[0]:-}"
            else
                _argc_die "error: the argument \`--password\` cannot be used multiple times"
            fi
            ;;
        --device-id | -d)
            _argc_take_args "--device-id <DEVICE-ID>" 1 1 "-" ""
            _argc_index=$((_argc_index + _argc_take_args_len + 1))
            if [[ -z "${argc_device_id:-}" ]]; then
                argc_device_id="${_argc_take_args_values[0]:-}"
            else
                _argc_die "error: the argument \`--device-id\` cannot be used multiple times"
            fi
            ;;
        --session-id)
            _argc_take_args "--session-id <SESSION-ID>" 1 1 "-" ""
            _argc_index=$((_argc_index + _argc_take_args_len + 1))
            if [[ -z "${argc_session_id:-}" ]]; then
                argc_session_id="${_argc_take_args_values[0]:-}"
            else
                _argc_die "error: the argument \`--session-id\` cannot be used multiple times"
            fi
            ;;
        --api-key | -k)
            _argc_take_args "--api-key <API-KEY>" 1 1 "-" ""
            _argc_index=$((_argc_index + _argc_take_args_len + 1))
            if [[ -z "${argc_api_key:-}" ]]; then
                argc_api_key="${_argc_take_args_values[0]:-}"
            else
                _argc_die "error: the argument \`--api-key\` cannot be used multiple times"
            fi
            ;;
        --quiet | -q)
            if [[ "$_argc_item" == *=* ]]; then
                _argc_die "error: flag \`--quiet\` don't accept any value"
            fi
            _argc_index=$((_argc_index + 1))
            if [[ -n "${argc_quiet:-}" ]]; then
                _argc_die "error: the argument \`--quiet\` cannot be used multiple times"
            else
                argc_quiet=1
            fi
            ;;
        --verbose | -v)
            if [[ "$_argc_item" == *=* ]]; then
                _argc_die "error: flag \`--verbose\` don't accept any value"
            fi
            _argc_index=$((_argc_index + 1))
            if [[ -n "${argc_verbose:-}" ]]; then
                _argc_die "error: the argument \`--verbose\` cannot be used multiple times"
            else
                argc_verbose=1
            fi
            ;;
        --compact | -C)
            if [[ "$_argc_item" == *=* ]]; then
                _argc_die "error: flag \`--compact\` don't accept any value"
            fi
            _argc_index=$((_argc_index + 1))
            if [[ -n "${argc_compact:-}" ]]; then
                _argc_die "error: the argument \`--compact\` cannot be used multiple times"
            else
                argc_compact=1
            fi
            ;;
        *)
            if _argc_maybe_flag_option "-" "$_argc_item"; then
                _argc_die "error: unexpected argument \`$_argc_key\` found"
            fi
            argc__positionals+=("$_argc_item")
            _argc_index=$((_argc_index + 1))
            ;;
        esac
    done
    if [[ -n "${_argc_action:-}" ]]; then
        $_argc_action
    else
        if [[ "${argc__positionals[0]:-}" == "help" ]] && [[ "${#argc__positionals[@]}" -eq 1 ]]; then
            _argc_usage
        fi
        _argc_match_positionals 0 0 0
        local values_index values_size
        IFS=: read -r values_index values_size <<<"${_argc_match_positionals_values[0]:-}"
        if [[ -n "$values_index" ]]; then
            argc_command="${argc__positionals[values_index]}"
        fi
        IFS=: read -r values_index values_size <<<"${_argc_match_positionals_values[1]:-}"
        if [[ -n "$values_index" ]]; then
            argc_value="${argc__positionals[values_index]}"
        fi
        IFS=: read -r values_index values_size <<<"${_argc_match_positionals_values[2]:-}"
        if [[ -n "$values_index" ]]; then
            argc_last_name="${argc__positionals[values_index]}"
        fi
    fi
}

_argc_take_args() {
    _argc_take_args_values=()
    _argc_take_args_len=0
    local param="$1" min="$2" max="$3" signs="$4" delimiter="$5"
    if [[ "$min" -eq 0 ]] && [[ "$max" -eq 0 ]]; then
        return
    fi
    local _argc_take_index=$((_argc_index + 1)) _argc_take_value
    if [[ "$_argc_item" == *=* ]]; then
        _argc_take_args_values=("${_argc_item##*=}")
    else
        while [[ $_argc_take_index -lt $_argc_len ]]; do
            _argc_take_value="${argc__args[_argc_take_index]}"
            if _argc_maybe_flag_option "$signs" "$_argc_take_value"; then
                if [[ "${#_argc_take_value}" -gt 1 ]]; then
                    break
                fi
            fi
            _argc_take_args_values+=("$_argc_take_value")
            _argc_take_args_len=$((_argc_take_args_len + 1))
            if [[ "$_argc_take_args_len" -ge "$max" ]]; then
                break
            fi
            _argc_take_index=$((_argc_take_index + 1))
        done
    fi
    if [[ "${#_argc_take_args_values[@]}" -lt "$min" ]]; then
        _argc_die "error: incorrect number of values for \`$param\`"
    fi
    if [[ -n "$delimiter" ]] && [[ "${#_argc_take_args_values[@]}" -gt 0 ]]; then
        local item values arr=()
        for item in "${_argc_take_args_values[@]}"; do
            IFS="$delimiter" read -r -a values <<<"$item"
            arr+=("${values[@]}")
        done
        _argc_take_args_values=("${arr[@]}")
    fi
}

_argc_match_positionals() {
    _argc_match_positionals_values=()
    _argc_match_positionals_len=0
    local params=("$@")
    local args_len="${#argc__positionals[@]}"
    if [[ $args_len -eq 0 ]]; then
        return
    fi
    local params_len=$# arg_index=0 param_index=0
    while [[ $param_index -lt $params_len && $arg_index -lt $args_len ]]; do
        local takes=0
        if [[ "${params[param_index]}" -eq 1 ]]; then
            if [[ $param_index -eq 0 ]] &&
                [[ ${_argc_dash:-} -gt 0 ]] &&
                [[ $params_len -eq 2 ]] &&
                [[ "${params[$((param_index + 1))]}" -eq 1 ]] \
                ; then
                takes=${_argc_dash:-}
            else
                local arg_diff=$((args_len - arg_index)) param_diff=$((params_len - param_index))
                if [[ $arg_diff -gt $param_diff ]]; then
                    takes=$((arg_diff - param_diff + 1))
                else
                    takes=1
                fi
            fi
        else
            takes=1
        fi
        _argc_match_positionals_values+=("$arg_index:$takes")
        arg_index=$((arg_index + takes))
        param_index=$((param_index + 1))
    done
    if [[ $arg_index -lt $args_len ]]; then
        _argc_match_positionals_values+=("$arg_index:$((args_len - arg_index))")
    fi
    _argc_match_positionals_len=${#_argc_match_positionals_values[@]}
    if [[ $params_len -gt 0 ]] && [[ $_argc_match_positionals_len -gt $params_len ]]; then
        local index="${_argc_match_positionals_values[params_len]%%:*}"
        _argc_die "error: unexpected argument \`${argc__positionals[index]}\` found"
    fi
}

_argc_maybe_flag_option() {
    local signs="$1" arg="$2"
    if [[ -z "$signs" ]]; then
        return 1
    fi
    local cond=false
    if [[ "$signs" == *"+"* ]]; then
        if [[ "$arg" =~ ^\+[^+].* ]]; then
            cond=true
        fi
    elif [[ "$arg" == -* ]]; then
        if (( ${#arg} < 3 )) || [[ ! "$arg" =~ ^---.* ]]; then
            cond=true
        fi
    fi
    if [[ "$cond" == "false" ]]; then
        return 1
    fi
    local value="${arg%%=*}"
    if [[ "$value" =~ [[:space:]] ]]; then
        return 1
    fi
    return 0
}

_argc_die() {
    if [[ $# -eq 0 ]]; then
        cat
    else
        echo "$*" >&2
    fi
    exit 1
}

_argc_run "$@"

# ARGC-BUILD }
argc_quiet=${argc_quiet:-0}
argc_verbose=${argc_verbose:-0}
argc_compact=${argc_compact:-0}
argc_email=${argc_email:-""}
argc_password=${argc_password:-""}
argc_device_id=${argc_device_id:-""}
argc_session_id=${argc_session_id:-""}
argc_api_key=${argc_api_key:-""}

setup_colors() {
  if [ "$argc_quiet" = 1 ] || [ -z "$TERM" ] || [ "$TERM" = "dumb" ]; then
    bold="" reset="" green="" yellow="" cyan="" red=""
  else
    bold=$(tput bold) reset=$(tput sgr0) green=$(tput setaf 2)
    yellow=$(tput setaf 3) cyan=$(tput setaf 6) red=$(tput setaf 1)
  fi
}
setup_colors

get_credential() {
  local arg_name="$1"
  local env_name="$2"
  local config_file="$3"

  local arg_value
  case "$arg_name" in
  "email") arg_value="$argc_email" ;;
  "password") arg_value="$argc_password" ;;
  "device-id") arg_value="$argc_device_id" ;;
  "session-id") arg_value="$argc_session_id" ;;
  "api-key") arg_value="$argc_api_key" ;;
  esac

  if [ -n "$arg_value" ]; then
    echo "$arg_value"
  elif [ -n "${!env_name}" ]; then
    echo "${!env_name}"
  elif [ -f "$HOME/.config/$(transform_api_str $CONFIG_DIR)/$config_file" ]; then
    cat "$HOME/.config/$(transform_api_str $CONFIG_DIR)/$config_file"
  else
    echo "${red}Error:${reset} No $arg_name found." >&2
    echo "Either:" >&2
    echo "  1. Pass it with --$arg_name" >&2
    echo "  2. Set $env_name environment variable" >&2
    echo "  3. Save it to ~/.config/$(transform_api_str $CONFIG_DIR)/$config_file" >&2
    exit 1
  fi
}

INTLS_EMAIL=$(get_credential "email" "INTLS_EMAIL" "email")
INTLS_PASSWORD=$(get_credential "password" "INTLS_PASSWORD" "password")
INTLS_DEVICE_ID=$(get_credential "device-id" "INTLS_DEVICE_ID" "device_id")
INTLS_SESSION_ID=$(get_credential "session-id" "INTLS_SESSION_ID" "session_id")
INTLS_API_KEY=$(get_credential "api-key" "INTLS_API_KEY" "api_key")

print_kv() {
  printf "${bold}%s:${reset} %s\n" "$1" "$2"
}

print_section() {
  printf "\n${bold}%s:${reset}\n" "$1"
}

authenticate() {
  local auth_resp
  auth_resp=$(curl -s "https://$(transform_api_str $API_DOMAIN)/v1/authenticate" --compressed -X POST \
    -H 'User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36' \
    -H 'Accept: */*' \
    -H 'Accept-Language: en-US,en;q=0.5' \
    -H 'Accept-Encoding: gzip, deflate, br' \
    -H "Referer: https://$(transform_api_str $WEB_DOMAIN)/login" \
    -H "api-key: $INTLS_API_KEY" \
    -H "app-id: $(transform_api_str intls)-web" \
    -H 'content-type: application/json' \
    -H "device-id: $INTLS_DEVICE_ID" \
    -H "Origin: https://$(transform_api_str $WEB_DOMAIN)" \
    -H 'Connection: keep-alive' \
    -H 'Sec-Fetch-Dest: empty' \
    -H 'Sec-Fetch-Mode: cors' \
    -H 'Sec-Fetch-Site: same-site' \
    -H 'Priority: u=0' \
    -H 'Pragma: no-cache' \
    -H 'Cache-Control: no-cache' \
    --data-raw "{\"email\":\"$INTLS_EMAIL\",\"password\":\"$INTLS_PASSWORD\",\"sessionId\":\"$INTLS_SESSION_ID\",\"sessionCreated\":\"\"}")

  local access_token
  access_token=$(echo "$auth_resp" | jq -r '.accessToken // ""')

  if [ -z "$access_token" ]; then
    echo "${red}Error:${reset} Failed to authenticate. Response was:" >&2
    echo "$auth_resp" | jq . >&2
    exit 1
  fi

  echo "$access_token"
}

make_request() {
  local api_url="$1"
  local referer="$2"
  local access_token="$3"

  curl -s "$api_url" --compressed \
    -H 'User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36' \
    -H 'Accept: */*' \
    -H 'Accept-Language: en-US,en;q=0.5' \
    -H 'Accept-Encoding: gzip, deflate, br' \
    -H "Referer: $referer" \
    -H "api-key: $INTLS_API_KEY" \
    -H "app-id: $(transform_api_str intls)-web" \
    -H "authorization: Bearer $access_token" \
    -H "device-id: $INTLS_DEVICE_ID" \
    -H "Origin: https://$(transform_api_str $WEB_DOMAIN)" \
    -H 'Connection: keep-alive' \
    -H "Cookie: sessionId=$INTLS_SESSION_ID; device-id=$INTLS_DEVICE_ID;" \
    -H 'Sec-Fetch-Dest: empty' \
    -H 'Sec-Fetch-Mode: cors' \
    -H 'Sec-Fetch-Site: same-site' \
    -H 'Priority: u=4' \
    -H 'Pragma: no-cache' \
    -H 'Cache-Control: no-cache'
}

make_post_request() {
  local api_url="$1"
  local referer="$2"
  local access_token="$3"
  local data="$4"

  curl -s "$api_url" --compressed -X POST \
    -H 'User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36' \
    -H 'Accept: */*' \
    -H 'Accept-Language: en-US,en;q=0.5' \
    -H 'Accept-Encoding: gzip, deflate, br' \
    -H "Referer: $referer" \
    -H "api-key: $INTLS_API_KEY" \
    -H "app-id: $(transform_api_str intls)-web" \
    -H "authorization: Bearer $access_token" \
    -H "device-id: $INTLS_DEVICE_ID" \
    -H "Origin: https://$(transform_api_str $WEB_DOMAIN)" \
    -H 'Connection: keep-alive' \
    -H "Cookie: sessionId=$INTLS_SESSION_ID; device-id=$INTLS_DEVICE_ID;" \
    -H 'content-type: application/json' \
    -H 'Sec-Fetch-Dest: empty' \
    -H 'Sec-Fetch-Mode: cors' \
    -H 'Sec-Fetch-Site: same-site' \
    -H 'Priority: u=4' \
    -H 'Pragma: no-cache' \
    -H 'Cache-Control: no-cache' \
    --data-raw "$data"
}

urlencode() {
  echo "${1// /%20}"
}

get_age_from_dob() {
  local dob="$1"
  if [[ "$dob" =~ ^[0-9]{4}-[0-9]{2}$ ]]; then
    local year="${dob%-*}"
    local current_year
    current_year=$(date +%Y)
    echo $((current_year - year))
  else
    echo "Unknown"
  fi
}

format_phone_hint() {
  local phone="$1"
  if [[ "$phone" =~ XXXXXX([0-9]{4}) ]]; then
    echo "***-***-${BASH_REMATCH[1]}"
  else
    echo "$phone"
  fi
}

display_person_selection() {
  local people_json="$1"

  # check if response is valid json first
  if ! echo "$people_json" | jq . >/dev/null 2>&1; then
    echo "${red}Error: Invalid response from API${reset}" >&2
    echo "Response: $people_json" >&2
    return 1
  fi

  local count
  count=$(echo "$people_json" | jq '. | length')

  if [ "$count" -eq 0 ]; then
    echo "${red}No people found.${reset}" >&2
    return 1
  fi

  if [ "$count" -eq 1 ]; then
    echo "${green}Found 1 person. Auto-selecting...${reset}" >&2
    echo "0"
    return 0
  fi

  echo "${bold}Found $count people:${reset}" >&2
  echo "" >&2

  for i in $(seq 0 $((count - 1))); do
    local person
    person=$(echo "$people_json" | jq ".[$i]")

    # extract basic info
    local name
    name=$(echo "$person" | jq -r '.names[0] | "\(.first // "") \(.middle // "") \(.last // "")" | gsub("  "; " ") | gsub("^ | $"; "")')
    local dob
    dob=$(echo "$person" | jq -r '.dob // ""')
    local age
    age=$(get_age_from_dob "$dob")

    # extract location info
    local location=""
    if echo "$person" | jq -e '.locations[0]' >/dev/null 2>&1; then
      local city
      city=$(echo "$person" | jq -r '.locations[0].address.city // ""')
      local state
      state=$(echo "$person" | jq -r '.locations[0].address.state_code // ""')
      if [ -n "$city" ] && [ -n "$state" ]; then
        location="$city, $state"
      elif [ -n "$city" ]; then
        location="$city"
      elif [ -n "$state" ]; then
        location="$state"
      fi
    fi

    # extract phone hints
    local phone_hints=""
    if echo "$person" | jq -e '.phones[0]' >/dev/null 2>&1; then
      local phone1=$(echo "$person" | jq -r '.phones[0].number // ""')
      local phone2=$(echo "$person" | jq -r '.phones[1].number // ""')

      if [ -n "$phone1" ]; then
        phone_hints=$(format_phone_hint "$phone1")
        if [ -n "$phone2" ]; then
          phone_hints="$phone_hints, $(format_phone_hint "$phone2")"
        fi
      fi
    fi

    printf "${bold}%d.${reset} %s" "$((i + 1))" "$name" >&2
    if [ -n "$age" ] && [ "$age" != "Unknown" ]; then
      printf " (Age: %s)" "$age" >&2
    fi
    if [ -n "$location" ]; then
      printf " - %s" "$location" >&2
    fi
    if [ -n "$phone_hints" ]; then
      printf " - %s" "$phone_hints" >&2
    fi
    echo "" >&2
  done

  echo "" >&2
  printf "${bold}Select a person (1-$count):${reset} " >&2
  read -r selection

  if [[ "$selection" =~ ^[0-9]+$ ]] && [ "$selection" -ge 1 ] && [ "$selection" -le "$count" ]; then
    echo $((selection - 1))
    return 0
  else
    echo "${red}Invalid selection.${reset}" >&2
    return 1
  fi
}

get_person_report() {
  local people_json="$1"
  local selected_index="$2"
  local access_token="$3"

  local person
  person=$(echo "$people_json" | jq ".[$selected_index]")

  local tcg_id
  tcg_id=$(echo "$person" | jq -r '.tcg_id')

  local search_pointer
  search_pointer=$(echo "$person" | jq -r '.searchPointer')

  # get the first name/location/dob for the record creation
  local first_name
  first_name=$(echo "$person" | jq -r '.names[0]')

  local first_location
  first_location=$(echo "$person" | jq -r '.locations[0]')

  local first_dob
  first_dob=$(echo "$person" | jq -r '.dobs[0]')

  echo "${yellow}Generating report for selected person...${reset}" >&2

  # step 1: send navigation event
  local nav_data="{\"name\":\"navigation:view\",\"page\":{\"host\":\"$(transform_api_str $WEB_DOMAIN)\",\"path\":\"\/dashboard\/reports\/$tcg_id\",\"route\":\"\/dashboard\/reports\/:recordId\"}}"
  local nav_response
  nav_response=$(make_post_request "https://$(transform_api_str $API_DOMAIN)/v1/events" \
    "https://$(transform_api_str $WEB_DOMAIN)/dashboard/reports/$tcg_id" \
    "$access_token" \
    "$nav_data")

  # step 2: create record
  local record_data
  record_data=$(jq -nc \
    --arg pointer "$search_pointer" \
    --argjson name "$first_name" \
    --argjson location "$first_location" \
    --argjson dob "$first_dob" \
    --arg tcg_id "$tcg_id" \
    '{
      "data": {
        "pointer": $pointer,
        "name": $name,
        "location": {"address": $location.address},
        "dobs": $dob,
        "tcg_id": $tcg_id
      },
      "type": "person"
    }')

  # tbh i am not sure that we actually need the response at all, seems like we just need to call it to trigger the report to generate. its sneed
  local record_response
  record_response=$(make_post_request "https://$(transform_api_str $API_DOMAIN)/v1/me/records" \
    "https://$(transform_api_str $WEB_DOMAIN)/dashboard/create-record?type=person&tcgId=$tcg_id&pointer=$(urlencode "$search_pointer")" \
    "$access_token" \
    "$record_data")

  # step 3: get the full report, u have to wait for the above query to finish whatever async crap it set up in the intelius side
  echo "${yellow}Fetching detailed report (this may take a moment)...${reset}" >&2
  local report_response
  report_response=$(make_request "https://$(transform_api_str $API_DOMAIN)/v1/me/records/$tcg_id/report?defer_extended_data=false" \
    "https://$(transform_api_str $WEB_DOMAIN)/dashboard/reports/$tcg_id" \
    "$access_token")

  echo "$report_response"
}

show_help() {
  echo "${bold}Intls Private API Client${reset}"
  echo ""
  echo "${bold}Commands:${reset}"
  echo "  ${cyan}phone${reset}         Look up information for a phone number"
  echo "  ${cyan}email${reset}         Look up information for an email address"
  echo "  ${cyan}people${reset}        Search for people by name with optional filters"
  echo "  ${cyan}address${reset}       Look up information about a specific address"
  echo ""
  echo "${bold}Examples:${reset}"
  echo "  ${green}$(basename "$0") phone 3014618574${reset}"
  echo "  ${green}$(basename "$0") email example@email.com${reset}"
  echo "  ${green}$(basename "$0") people John Doe --city \"New York\" --state NY --age 34${reset}"
  echo "  ${green}$(basename "$0") address --street \"123 Main St\" --city \"Santa Clara\" --state CA --zip 95050${reset}"
  echo ""
  echo "${bold}Authentication:${reset}"
  echo "  Set environment variables or use command line options:"
  echo "  ${yellow}INTLS_EMAIL, INTLS_PASSWORD, INTLS_DEVICE_ID,${reset}"
  echo "  ${yellow}INTLS_SESSION_ID, INTLS_API_KEY${reset}"
}

filter_json_output() {
  local input="$1"
  local jq_filter=""
  local jq_options=""

  # Apply verbose filtering unless verbose flag is set
  if [ "$argc_verbose" != 1 ]; then
    jq_filter="walk(if type == \"object\" then del(.provider, .data_point_id, .tcg_id, .search_pointer) else . end)"
  else
    jq_filter="."
  fi

  # Apply compact formatting if compact flag is set
  if [ "$argc_compact" = 1 ]; then
    jq_options="-c"
  else
    jq_options="--indent 2"
    # Only add color output if not compact and not quiet
    if [ "$argc_quiet" != 1 ]; then
      jq_options="$jq_options --color-output"
    fi
  fi

  echo "$input" | jq $jq_options "$jq_filter"
}

validate_phone() {
  local phone="$1"
  if [[ "$phone" == +1* ]]; then
    echo "${red}Error:${reset} Phone number should not start with +1" >&2
    exit 1
  fi
  if [[ ! "$phone" =~ ^[0-9]{10}$ ]]; then
    echo "${red}Error:${reset} Phone number must be 10 digits" >&2
    exit 1
  fi
}

if [ -z "$argc_command" ]; then
  show_help
  exit 0
fi

ACCESS_TOKEN=$(authenticate)

case "$argc_command" in
phone)
  if [ -z "$argc_value" ]; then
    echo "${red}Error:${reset} Phone number is required." >&2
    echo "Usage: $(basename "$0") phone <phone_number>" >&2
    exit 1
  fi
  validate_phone "$argc_value"
  api_url="https://$(transform_api_str $API_DOMAIN)/v1/phones/$argc_value"
  referer="https://$(transform_api_str $WEB_DOMAIN)/dashboard/search?phone=$argc_value"
  response=$(make_request "$api_url" "$referer" "$ACCESS_TOKEN")
  filter_json_output "$response"
  ;;

email)
  if [ -z "$argc_value" ]; then
    echo "${red}Error:${reset} Email address is required." >&2
    echo "Usage: $(basename "$0") email <email_address>" >&2
    exit 1
  fi
  if [[ ! "$argc_value" =~ ^[^@]+@[^@]+\.[^@]+$ ]]; then
    echo "${red}Error:${reset} Invalid email format." >&2
    exit 1
  fi
  api_url="https://$(transform_api_str $API_DOMAIN)/v1/emails/$argc_value"
  referer="https://$(transform_api_str $WEB_DOMAIN)/dashboard/search?email=$argc_value"
  response=$(make_request "$api_url" "$referer" "$ACCESS_TOKEN")
  filter_json_output "$response"
  ;;

people)
  if [ -z "$argc_value" ] || [ -z "$argc_last_name" ]; then
    echo "${red}Error:${reset} First name and last name are required." >&2
    echo "Usage: $(basename "$0") people <first_name> <last_name> [options]" >&2
    exit 1
  fi

  query_params="firstName=$argc_value&lastName=$argc_last_name"

  if [ -n "$argc_city" ]; then
    query_params="$query_params&city=$(urlencode "$argc_city")"
  fi

  if [ -n "$argc_state" ] && [ "$argc_state" != "ALL" ]; then
    query_params="$query_params&state=$argc_state"
  fi

  if [ -n "$argc_age" ]; then
    query_params="$query_params&age=$argc_age"
  fi

  api_url="https://$(transform_api_str $API_DOMAIN)/v1/people?$query_params"
  referer="https://$(transform_api_str $WEB_DOMAIN)/dashboard/search?firstName=$argc_value&lastName=$argc_last_name&state=$argc_state"
  response=$(make_request "$api_url" "$referer" "$ACCESS_TOKEN")

  # show person selection and get detailed report
  selected_index=$(display_person_selection "$response")
  if [ $? -eq 0 ]; then
    detailed_report=$(get_person_report "$response" "$selected_index" "$ACCESS_TOKEN")
    filter_json_output "$detailed_report"
  fi
  ;;

address)
  if [ -z "$argc_street" ] || [ -z "$argc_city" ] || [ -z "$argc_state" ] || [ -z "$argc_zip" ]; then
    echo "${red}Error:${reset} Street, city, state, and zip are required for address search." >&2
    echo "Usage: $(basename "$0") address --street <street> --city <city> --state <state> --zip <zip>" >&2
    exit 1
  fi

  street_encoded=$(urlencode "$argc_street")
  city_encoded=$(urlencode "$argc_city")

  query_params="street=$street_encoded&city=$city_encoded&state=$argc_state&zip=$argc_zip"

  api_url="https://$(transform_api_str $API_DOMAIN)/v1/locations?$query_params"
  referer="https://$(transform_api_str $WEB_DOMAIN)/dashboard/search?address=$(urlencode "$argc_street $argc_city $argc_state")"
  response=$(make_request "$api_url" "$referer" "$ACCESS_TOKEN")
  filter_json_output "$response"
  ;;

*)
  echo "${red}Error:${reset} Unknown command: ${argc_command}" >&2
  show_help
  exit 1
  ;;
esac
