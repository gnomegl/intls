#!/usr/bin/env bash

# @describe Intls Private API - Query the Intls database directly
# @arg command "Command to run (phone, email, people, address)" [string]
# @arg value "Value to search for (phone number, email address, or first name for people)" [string]
# @arg last-name "Last name (required for people command)" [string]
# @option -c --city "City name for people/address search" [string]
# @option -s --state "Two-letter state code" [string] @default "ALL"
# @option -a --age "Age for people search" [string]
# @option -z --zip "ZIP code for address search" [string]
# @option -t --street "Street address for address search" [string]
# @option -e --email "Intls email (can also use INTLS_EMAIL env var)" [string]
# @option -p --password "Intls password (can also use INTLS_PASSWORD env var)" [string]
# @option -d --device-id "Device ID (can also use INTLS_DEVICE_ID env var)" [string]
# @option --session-id "Session ID (can also use INTLS_SESSION_ID env var)" [string]
# @option -k --api-key "API key (can also use INTLS_API_KEY env var)" [string]
# @flag   -j --json "Output raw JSON instead of formatted results"
# @flag   -q --quiet "Suppress colored output"

transform_api_str() {
  echo "${1//intls/int$(echo -n 'el')$(echo -n 'iu')s}"
}

# Base domains and paths that will be transformed
CONFIG_DIR="intls"
API_DOMAIN="api.intls.com"
WEB_DOMAIN="www.intls.com"

# ARGC-BUILD {
# This block was generated by argc (https://github.com/sigoden/argc).
# Modifying it manually is not recommended

_argc_run() {
    if [[ "${1:-}" == "___internal___" ]]; then
        _argc_die "error: unsupported ___internal___ command"
    fi
    if [[ "${OS:-}" == "Windows_NT" ]] && [[ -n "${MSYSTEM:-}" ]]; then
        set -o igncr
    fi
    argc__args=("$(basename "$0" .sh)" "$@")
    argc__positionals=()
    _argc_index=1
    _argc_len="${#argc__args[@]}"
    _argc_tools=()
    _argc_parse
    if [ -n "${argc__fn:-}" ]; then
        $argc__fn "${argc__positionals[@]}"
    fi
}

_argc_usage() {
    cat <<-'EOF'
Intls Private API - Query the Intls database directly

USAGE: intls [OPTIONS] [COMMAND] [VALUE] [LAST-NAME]

ARGS:
  [COMMAND]    "Command to run (phone, email, people, address)" [string]
  [VALUE]      "Value to search for (phone number, email address, or first name for people)" [string]
  [LAST-NAME]  "Last name (required for people command)" [string]

OPTIONS:
  -c, --city <CITY>              "City name for people/address search" [string]
  -s, --state <STATE>            "Two-letter state code" [string] @default "ALL"
  -a, --age <AGE>                "Age for people search" [string]
  -z, --zip <ZIP>                "ZIP code for address search" [string]
  -t, --street <STREET>          "Street address for address search" [string]
  -e, --email <EMAIL>            "Intls email (can also use INTLS_EMAIL env var)" [string]
  -p, --password <PASSWORD>      "Intls password (can also use INTLS_PASSWORD env var)" [string]
  -d, --device-id <DEVICE-ID>    "Device ID (can also use INTLS_DEVICE_ID env var)" [string]
      --session-id <SESSION-ID>  "Session ID (can also use INTLS_SESSION_ID env var)" [string]
  -k, --api-key <API-KEY>        "API key (can also use INTLS_API_KEY env var)" [string]
  -j, --json                     "Output raw JSON instead of formatted results"
  -q, --quiet                    "Suppress colored output"
  -h, --help                     Print help
  -V, --version                  Print version
EOF
    exit
}

_argc_version() {
    echo intls 0.0.0
    exit
}

_argc_parse() {
    local _argc_key _argc_action
    local _argc_subcmds=""
    while [[ $_argc_index -lt $_argc_len ]]; do
        _argc_item="${argc__args[_argc_index]}"
        _argc_key="${_argc_item%%=*}"
        case "$_argc_key" in
        --help | -help | -h)
            _argc_usage
            ;;
        --version | -version | -V)
            _argc_version
            ;;
        --)
            _argc_dash="${#argc__positionals[@]}"
            argc__positionals+=("${argc__args[@]:$((_argc_index + 1))}")
            _argc_index=$_argc_len
            break
            ;;
        --city | -c)
            _argc_take_args "--city <CITY>" 1 1 "-" ""
            _argc_index=$((_argc_index + _argc_take_args_len + 1))
            if [[ -z "${argc_city:-}" ]]; then
                argc_city="${_argc_take_args_values[0]:-}"
            else
                _argc_die "error: the argument \`--city\` cannot be used multiple times"
            fi
            ;;
        --state | -s)
            _argc_take_args "--state <STATE>" 1 1 "-" ""
            _argc_index=$((_argc_index + _argc_take_args_len + 1))
            if [[ -z "${argc_state:-}" ]]; then
                argc_state="${_argc_take_args_values[0]:-}"
            else
                _argc_die "error: the argument \`--state\` cannot be used multiple times"
            fi
            ;;
        --age | -a)
            _argc_take_args "--age <AGE>" 1 1 "-" ""
            _argc_index=$((_argc_index + _argc_take_args_len + 1))
            if [[ -z "${argc_age:-}" ]]; then
                argc_age="${_argc_take_args_values[0]:-}"
            else
                _argc_die "error: the argument \`--age\` cannot be used multiple times"
            fi
            ;;
        --zip | -z)
            _argc_take_args "--zip <ZIP>" 1 1 "-" ""
            _argc_index=$((_argc_index + _argc_take_args_len + 1))
            if [[ -z "${argc_zip:-}" ]]; then
                argc_zip="${_argc_take_args_values[0]:-}"
            else
                _argc_die "error: the argument \`--zip\` cannot be used multiple times"
            fi
            ;;
        --street | -t)
            _argc_take_args "--street <STREET>" 1 1 "-" ""
            _argc_index=$((_argc_index + _argc_take_args_len + 1))
            if [[ -z "${argc_street:-}" ]]; then
                argc_street="${_argc_take_args_values[0]:-}"
            else
                _argc_die "error: the argument \`--street\` cannot be used multiple times"
            fi
            ;;
        --email | -e)
            _argc_take_args "--email <EMAIL>" 1 1 "-" ""
            _argc_index=$((_argc_index + _argc_take_args_len + 1))
            if [[ -z "${argc_email:-}" ]]; then
                argc_email="${_argc_take_args_values[0]:-}"
            else
                _argc_die "error: the argument \`--email\` cannot be used multiple times"
            fi
            ;;
        --password | -p)
            _argc_take_args "--password <PASSWORD>" 1 1 "-" ""
            _argc_index=$((_argc_index + _argc_take_args_len + 1))
            if [[ -z "${argc_password:-}" ]]; then
                argc_password="${_argc_take_args_values[0]:-}"
            else
                _argc_die "error: the argument \`--password\` cannot be used multiple times"
            fi
            ;;
        --device-id | -d)
            _argc_take_args "--device-id <DEVICE-ID>" 1 1 "-" ""
            _argc_index=$((_argc_index + _argc_take_args_len + 1))
            if [[ -z "${argc_device_id:-}" ]]; then
                argc_device_id="${_argc_take_args_values[0]:-}"
            else
                _argc_die "error: the argument \`--device-id\` cannot be used multiple times"
            fi
            ;;
        --session-id)
            _argc_take_args "--session-id <SESSION-ID>" 1 1 "-" ""
            _argc_index=$((_argc_index + _argc_take_args_len + 1))
            if [[ -z "${argc_session_id:-}" ]]; then
                argc_session_id="${_argc_take_args_values[0]:-}"
            else
                _argc_die "error: the argument \`--session-id\` cannot be used multiple times"
            fi
            ;;
        --api-key | -k)
            _argc_take_args "--api-key <API-KEY>" 1 1 "-" ""
            _argc_index=$((_argc_index + _argc_take_args_len + 1))
            if [[ -z "${argc_api_key:-}" ]]; then
                argc_api_key="${_argc_take_args_values[0]:-}"
            else
                _argc_die "error: the argument \`--api-key\` cannot be used multiple times"
            fi
            ;;
        --json | -j)
            if [[ "$_argc_item" == *=* ]]; then
                _argc_die "error: flag \`--json\` don't accept any value"
            fi
            _argc_index=$((_argc_index + 1))
            if [[ -n "${argc_json:-}" ]]; then
                _argc_die "error: the argument \`--json\` cannot be used multiple times"
            else
                argc_json=1
            fi
            ;;
        --quiet | -q)
            if [[ "$_argc_item" == *=* ]]; then
                _argc_die "error: flag \`--quiet\` don't accept any value"
            fi
            _argc_index=$((_argc_index + 1))
            if [[ -n "${argc_quiet:-}" ]]; then
                _argc_die "error: the argument \`--quiet\` cannot be used multiple times"
            else
                argc_quiet=1
            fi
            ;;
        *)
            if _argc_maybe_flag_option "-" "$_argc_item"; then
                _argc_die "error: unexpected argument \`$_argc_key\` found"
            fi
            argc__positionals+=("$_argc_item")
            _argc_index=$((_argc_index + 1))
            ;;
        esac
    done
    if [[ -n "${_argc_action:-}" ]]; then
        $_argc_action
    else
        if [[ "${argc__positionals[0]:-}" == "help" ]] && [[ "${#argc__positionals[@]}" -eq 1 ]]; then
            _argc_usage
        fi
        _argc_match_positionals 0 0 0
        local values_index values_size
        IFS=: read -r values_index values_size <<<"${_argc_match_positionals_values[0]:-}"
        if [[ -n "$values_index" ]]; then
            argc_command="${argc__positionals[values_index]}"
        fi
        IFS=: read -r values_index values_size <<<"${_argc_match_positionals_values[1]:-}"
        if [[ -n "$values_index" ]]; then
            argc_value="${argc__positionals[values_index]}"
        fi
        IFS=: read -r values_index values_size <<<"${_argc_match_positionals_values[2]:-}"
        if [[ -n "$values_index" ]]; then
            argc_last_name="${argc__positionals[values_index]}"
        fi
    fi
}

_argc_take_args() {
    _argc_take_args_values=()
    _argc_take_args_len=0
    local param="$1" min="$2" max="$3" signs="$4" delimiter="$5"
    if [[ "$min" -eq 0 ]] && [[ "$max" -eq 0 ]]; then
        return
    fi
    local _argc_take_index=$((_argc_index + 1)) _argc_take_value
    if [[ "$_argc_item" == *=* ]]; then
        _argc_take_args_values=("${_argc_item##*=}")
    else
        while [[ $_argc_take_index -lt $_argc_len ]]; do
            _argc_take_value="${argc__args[_argc_take_index]}"
            if _argc_maybe_flag_option "$signs" "$_argc_take_value"; then
                if [[ "${#_argc_take_value}" -gt 1 ]]; then
                    break
                fi
            fi
            _argc_take_args_values+=("$_argc_take_value")
            _argc_take_args_len=$((_argc_take_args_len + 1))
            if [[ "$_argc_take_args_len" -ge "$max" ]]; then
                break
            fi
            _argc_take_index=$((_argc_take_index + 1))
        done
    fi
    if [[ "${#_argc_take_args_values[@]}" -lt "$min" ]]; then
        _argc_die "error: incorrect number of values for \`$param\`"
    fi
    if [[ -n "$delimiter" ]] && [[ "${#_argc_take_args_values[@]}" -gt 0 ]]; then
        local item values arr=()
        for item in "${_argc_take_args_values[@]}"; do
            IFS="$delimiter" read -r -a values <<<"$item"
            arr+=("${values[@]}")
        done
        _argc_take_args_values=("${arr[@]}")
    fi
}

_argc_match_positionals() {
    _argc_match_positionals_values=()
    _argc_match_positionals_len=0
    local params=("$@")
    local args_len="${#argc__positionals[@]}"
    if [[ $args_len -eq 0 ]]; then
        return
    fi
    local params_len=$# arg_index=0 param_index=0
    while [[ $param_index -lt $params_len && $arg_index -lt $args_len ]]; do
        local takes=0
        if [[ "${params[param_index]}" -eq 1 ]]; then
            if [[ $param_index -eq 0 ]] &&
                [[ ${_argc_dash:-} -gt 0 ]] &&
                [[ $params_len -eq 2 ]] &&
                [[ "${params[$((param_index + 1))]}" -eq 1 ]] \
                ; then
                takes=${_argc_dash:-}
            else
                local arg_diff=$((args_len - arg_index)) param_diff=$((params_len - param_index))
                if [[ $arg_diff -gt $param_diff ]]; then
                    takes=$((arg_diff - param_diff + 1))
                else
                    takes=1
                fi
            fi
        else
            takes=1
        fi
        _argc_match_positionals_values+=("$arg_index:$takes")
        arg_index=$((arg_index + takes))
        param_index=$((param_index + 1))
    done
    if [[ $arg_index -lt $args_len ]]; then
        _argc_match_positionals_values+=("$arg_index:$((args_len - arg_index))")
    fi
    _argc_match_positionals_len=${#_argc_match_positionals_values[@]}
    if [[ $params_len -gt 0 ]] && [[ $_argc_match_positionals_len -gt $params_len ]]; then
        local index="${_argc_match_positionals_values[params_len]%%:*}"
        _argc_die "error: unexpected argument \`${argc__positionals[index]}\` found"
    fi
}

_argc_maybe_flag_option() {
    local signs="$1" arg="$2"
    if [[ -z "$signs" ]]; then
        return 1
    fi
    local cond=false
    if [[ "$signs" == *"+"* ]]; then
        if [[ "$arg" =~ ^\+[^+].* ]]; then
            cond=true
        fi
    elif [[ "$arg" == -* ]]; then
        if (( ${#arg} < 3 )) || [[ ! "$arg" =~ ^---.* ]]; then
            cond=true
        fi
    fi
    if [[ "$cond" == "false" ]]; then
        return 1
    fi
    local value="${arg%%=*}"
    if [[ "$value" =~ [[:space:]] ]]; then
        return 1
    fi
    return 0
}

_argc_die() {
    if [[ $# -eq 0 ]]; then
        cat
    else
        echo "$*" >&2
    fi
    exit 1
}

_argc_run "$@"

# ARGC-BUILD }

argc_quiet=0
argc_json=0
argc_email=""
argc_password=""
argc_device_id=""
argc_session_id=""
argc_api_key=""

setup_colors() {
  if [ "$argc_quiet" = 1 ] || [ -z "$TERM" ] || [ "$TERM" = "dumb" ]; then
    bold="" reset="" green="" yellow="" cyan="" red=""
  else
    bold=$(tput bold) reset=$(tput sgr0) green=$(tput setaf 2)
    yellow=$(tput setaf 3) cyan=$(tput setaf 6) red=$(tput setaf 1)
  fi
}
setup_colors

get_credential() {
  local arg_name="$1"
  local env_name="$2"
  local config_file="$3"

  local arg_value
  case "$arg_name" in
  "email") arg_value="$argc_email" ;;
  "password") arg_value="$argc_password" ;;
  "device-id") arg_value="$argc_device_id" ;;
  "session-id") arg_value="$argc_session_id" ;;
  "api-key") arg_value="$argc_api_key" ;;
  esac

  if [ -n "$arg_value" ]; then
    echo "$arg_value"
  elif [ -n "${!env_name}" ]; then
    echo "${!env_name}"
  elif [ -f "$HOME/.config/$(transform_api_str $CONFIG_DIR)/$config_file" ]; then
    cat "$HOME/.config/$(transform_api_str $CONFIG_DIR)/$config_file"
  else
    echo "${red}Error:${reset} No $arg_name found." >&2
    echo "Either:" >&2
    echo "  1. Pass it with --$arg_name" >&2
    echo "  2. Set $env_name environment variable" >&2
    echo "  3. Save it to ~/.config/$(transform_api_str $CONFIG_DIR)/$config_file" >&2
    exit 1
  fi
}

INTLS_EMAIL=$(get_credential "email" "INTLS_EMAIL" "email")
INTLS_PASSWORD=$(get_credential "password" "INTLS_PASSWORD" "password")
INTLS_DEVICE_ID=$(get_credential "device-id" "INTLS_DEVICE_ID" "device_id")
INTLS_SESSION_ID=$(get_credential "session-id" "INTLS_SESSION_ID" "session_id")
INTLS_API_KEY=$(get_credential "api-key" "INTLS_API_KEY" "api_key")

print_kv() {
  printf "${bold}%s:${reset} %s\n" "$1" "$2"
}

print_section() {
  printf "\n${bold}%s:${reset}\n" "$1"
}

authenticate() {
  local auth_resp
  auth_resp=$(curl -s "https://$(transform_api_str $API_DOMAIN)/v1/authenticate" --compressed -X POST \
    -H 'User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36' \
    -H 'Accept: */*' \
    -H 'Accept-Language: en-US,en;q=0.5' \
    -H 'Accept-Encoding: gzip, deflate, br' \
    -H "Referer: https://$(transform_api_str $WEB_DOMAIN)/login" \
    -H "api-key: $INTLS_API_KEY" \
    -H "app-id: $(transform_api_str intls)-web" \
    -H 'content-type: application/json' \
    -H "device-id: $INTLS_DEVICE_ID" \
    -H "Origin: https://$(transform_api_str $WEB_DOMAIN)" \
    -H 'Connection: keep-alive' \
    -H 'Sec-Fetch-Dest: empty' \
    -H 'Sec-Fetch-Mode: cors' \
    -H 'Sec-Fetch-Site: same-site' \
    -H 'Priority: u=0' \
    -H 'Pragma: no-cache' \
    -H 'Cache-Control: no-cache' \
    --data-raw "{\"email\":\"$INTLS_EMAIL\",\"password\":\"$INTLS_PASSWORD\",\"sessionId\":\"$INTLS_SESSION_ID\",\"sessionCreated\":\"\"}")

  local access_token
  access_token=$(echo "$auth_resp" | jq -r '.accessToken // ""')

  if [ -z "$access_token" ]; then
    echo "${red}Error:${reset} Failed to authenticate. Response was:" >&2
    echo "$auth_resp" >&2
    exit 1
  fi

  echo "$access_token"
}

make_request() {
  local api_url="$1"
  local referer="$2"
  local access_token="$3"

  curl -s "$api_url" --compressed \
    -H 'User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36' \
    -H 'Accept: */*' \
    -H 'Accept-Language: en-US,en;q=0.5' \
    -H 'Accept-Encoding: gzip, deflate, br' \
    -H "Referer: $referer" \
    -H "api-key: $INTLS_API_KEY" \
    -H "app-id: $(transform_api_str intls)-web" \
    -H "authorization: Bearer $access_token" \
    -H "device-id: $INTLS_DEVICE_ID" \
    -H "Origin: https://$(transform_api_str $WEB_DOMAIN)" \
    -H 'Connection: keep-alive' \
    -H "Cookie: sessionId=$INTLS_SESSION_ID; device-id=$INTLS_DEVICE_ID;" \
    -H 'Sec-Fetch-Dest: empty' \
    -H 'Sec-Fetch-Mode: cors' \
    -H 'Sec-Fetch-Site: same-site' \
    -H 'Priority: u=4' \
    -H 'Pragma: no-cache' \
    -H 'Cache-Control: no-cache'
}

urlencode() {
  echo "${1// /%20}"
}

show_help() {
  echo "${bold}Intls Private API Client${reset}"
  echo ""
  echo "${bold}Commands:${reset}"
  echo "  ${cyan}phone${reset}         Look up information for a phone number"
  echo "  ${cyan}email${reset}         Look up information for an email address"
  echo "  ${cyan}people${reset}        Search for people by name with optional filters"
  echo "  ${cyan}address${reset}       Look up information about a specific address"
  echo ""
  echo "${bold}Examples:${reset}"
  echo "  ${green}$(basename "$0") phone 3014618574${reset}"
  echo "  ${green}$(basename "$0") email example@email.com${reset}"
  echo "  ${green}$(basename "$0") people John Doe --city \"New York\" --state NY --age 34${reset}"
  echo "  ${green}$(basename "$0") address --street \"123 Main St\" --city \"Santa Clara\" --state CA --zip 95050${reset}"
  echo ""
  echo "${bold}Authentication:${reset}"
  echo "  Set environment variables or use command line options:"
  echo "  ${yellow}INTLS_EMAIL, INTLS_PASSWORD, INTLS_DEVICE_ID,${reset}"
  echo "  ${yellow}INTLS_SESSION_ID, INTLS_API_KEY${reset}"
}

validate_phone() {
  local phone="$1"
  if [[ "$phone" == +1* ]]; then
    echo "${red}Error:${reset} Phone number should not start with +1" >&2
    exit 1
  fi
  if [[ ! "$phone" =~ ^[0-9]{10}$ ]]; then
    echo "${red}Error:${reset} Phone number must be 10 digits" >&2
    exit 1
  fi
}

if [ -z "$argc_command" ]; then
  show_help
  exit 0
fi

ACCESS_TOKEN=$(authenticate)

case "$argc_command" in
phone)
  if [ -z "$argc_value" ]; then
    echo "${red}Error:${reset} Phone number is required." >&2
    echo "Usage: $(basename "$0") phone <phone_number>" >&2
    exit 1
  fi
  validate_phone "$argc_value"
  api_url="https://$(transform_api_str $API_DOMAIN)/v1/phones/$argc_value"
  referer="https://$(transform_api_str $WEB_DOMAIN)/dashboard/search?phone=$argc_value"
  response=$(make_request "$api_url" "$referer" "$ACCESS_TOKEN")
  [ "$argc_json" = 1 ] && echo "$response" | jq . || echo "$response"
  ;;

email)
  if [ -z "$argc_value" ]; then
    echo "${red}Error:${reset} Email address is required." >&2
    echo "Usage: $(basename "$0") email <email_address>" >&2
    exit 1
  fi
  if [[ ! "$argc_value" =~ ^[^@]+@[^@]+\.[^@]+$ ]]; then
    echo "${red}Error:${reset} Invalid email format." >&2
    exit 1
  fi
  api_url="https://$(transform_api_str $API_DOMAIN)/v1/emails/$argc_value"
  referer="https://$(transform_api_str $WEB_DOMAIN)/dashboard/search?email=$argc_value"
  response=$(make_request "$api_url" "$referer" "$ACCESS_TOKEN")
  [ "$argc_json" = 1 ] && echo "$response" | jq . || echo "$response"
  ;;

people)
  if [ -z "$argc_value" ] || [ -z "$argc_last_name" ]; then
    echo "${red}Error:${reset} First name and last name are required." >&2
    echo "Usage: $(basename "$0") people <first_name> <last_name> [options]" >&2
    exit 1
  fi

  query_params="firstName=$argc_value&lastName=$argc_last_name"

  if [ -n "$argc_city" ]; then
    query_params="$query_params&city=$(urlencode "$argc_city")"
  fi

  if [ -n "$argc_state" ] && [ "$argc_state" != "ALL" ]; then
    query_params="$query_params&state=$argc_state"
  fi

  if [ -n "$argc_age" ]; then
    query_params="$query_params&age=$argc_age"
  fi

  api_url="https://$(transform_api_str $API_DOMAIN)/v1/people?$query_params"
  referer="https://$(transform_api_str $WEB_DOMAIN)/dashboard/search?name=$(urlencode "$argc_value $argc_last_name")"
  response=$(make_request "$api_url" "$referer" "$ACCESS_TOKEN")
  [ "$argc_json" = 1 ] && echo "$response" | jq . || echo "$response"
  ;;

address)
  if [ -z "$argc_street" ] || [ -z "$argc_city" ] || [ -z "$argc_state" ] || [ -z "$argc_zip" ]; then
    echo "${red}Error:${reset} Street, city, state, and zip are required for address search." >&2
    echo "Usage: $(basename "$0") address --street <street> --city <city> --state <state> --zip <zip>" >&2
    exit 1
  fi

  street_encoded=$(urlencode "$argc_street")
  city_encoded=$(urlencode "$argc_city")

  query_params="street=$street_encoded&city=$city_encoded&state=$argc_state&zip=$argc_zip"

  api_url="https://$(transform_api_str $API_DOMAIN)/v1/locations?$query_params"
  referer="https://$(transform_api_str $WEB_DOMAIN)/dashboard/search?address=$(urlencode "$argc_street $argc_city $argc_state")"
  response=$(make_request "$api_url" "$referer" "$ACCESS_TOKEN")
  [ "$argc_json" = 1 ] && echo "$response" | jq . || echo "$response"
  ;;

*)
  echo "${red}Error:${reset} Unknown command: ${argc_command}" >&2
  show_help
  exit 1
  ;;
esac
